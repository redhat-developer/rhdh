# Copyright Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Build Next and Tag Image

on:
  # workflow_dispatch so that it can be triggered manually if needed
  workflow_dispatch:
    inputs:
      registry_image:
        description: "Target registry/repository (e.g., polasudo/testing)"
        required: false
        default: "polasudo/testing"
      test_cleanup:
        description: "Enable cleanup testing (true/false)"
        required: false
        default: "true"
  schedule:
    # run at 3:18 UTC every day
    - cron: "18 3 * * *"

  # in addition to building multi-arch :next images daily,
  # also build multi-arch images for any x.y or x.y.z tag pushed to the repo
  push:
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'
      - '[0-9]+.[0-9]+'
    branches:
      - 'release-**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: quay.io
  REGISTRY_IMAGE: polasudo/testing

jobs:
  build-image:
    name: Build Image
    env:
      HAS_QUAY_AUTH: ${{ secrets.QUAY_USERNAME != '' && secrets.QUAY_TOKEN != '' }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-24.04-arm
          - ubuntu-24.04
    runs-on: ${{ matrix.os }}
    timeout-minutes: 720 # Set to 12 hours instead of default 360 = 6hrs
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare
        run: |
          if [ "${{ matrix.os }}" == "ubuntu-24.04" ]; then
            platform="linux/amd64"
          elif [ "${{ matrix.os }}" == "ubuntu-24.04-arm" ]; then
            platform="linux/arm64"
          else
            echo "Unknown platform"
            exit 1
          fi

          ref_name=${{ github.ref_name }}
          if [ "$ref_name" == "main" ]; then
            ref_name="next"
          elif [[ "$ref_name" =~ ^release-([0-9]+)\.([0-9]+) ]]; then
            # next-1.y
            ref_name="next-${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
          fi
          ref_name_short="${ref_name}"

          # for releases only
          if [[ $ref_name != "next" ]] && [[ $ref_name != "next-"* ]]; then
            # shorten from 1.6.1 => 1.6
            ref_name_short="${ref_name%.*}"
            if [[ $ref_name_short == "1" ]]; then ref_name_short="${ref_name}"; fi
          fi

          echo "REF_NAME=$ref_name" >> $GITHUB_ENV
          echo "REF_NAME_SHORT=${ref_name_short}" >> $GITHUB_ENV
          echo "PLATFORM=$platform" >> $GITHUB_ENV
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV
          echo "PLATFORM_ARCH=${platform#*/}" >> $GITHUB_ENV

          # compute expiry once and reuse
          if [[ "$ref_name_short" == "next" ]] || [[ "$ref_name_short" == next-* ]]; then
            expires_after="14d"  # Short expiry for next builds
          elif [[ "$ref_name_short" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
            expires_after="183d" # Long expiry for official releases (1.2, 1.2.3, etc.)
          else
            expires_after="14d"  # Short expiry for feature branches and other temporary builds
          fi
          echo "EXPIRES_AFTER=$expires_after" >> $GITHUB_ENV

          # allow overriding target image when manually dispatched for testing
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.registry_image }}" ]; then
            echo "REGISTRY_IMAGE=${{ inputs.registry_image }}" >> $GITHUB_ENV
            echo "Using test registry: ${{ inputs.registry_image }}"
          fi

      - name: Check Quay credentials
        run: |
          if [ "${{ env.HAS_QUAY_AUTH }}" != "true" ]; then
            echo "::error::Missing QUAY_USERNAME or QUAY_TOKEN secrets"
            exit 1
          fi
          echo "✓ Quay credentials are available"

      - name: Login to Quay
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}

      - name: Get the last commit short SHA
        uses: ./.github/actions/get-sha

      - name: Build and Push with Buildx (for :next builds, 14d expiry)
        uses: ./.github/actions/docker-build
        id: build-next
        if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
          imageName: ${{ env.REGISTRY_IMAGE }}
          imageTags: |
            type=raw,value=${{ env.REF_NAME }}-${{ env.PLATFORM_ARCH }}
            type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}-${{ env.PLATFORM_ARCH }}
          imageLabels: |
            quay.expires-after=${{ env.EXPIRES_AFTER }}
            org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}
          push: true
          platform: ${{ env.PLATFORM }}

      - name: Build and Push with Buildx (for releases, 183d expiry)
        uses: ./.github/actions/docker-build
        id: build-release
        if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
          imageName: ${{ env.REGISTRY_IMAGE }}
          imageTags: |
            type=raw,value=${{ env.REF_NAME }}-${{ env.PLATFORM_ARCH }}
            type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}-${{ env.PLATFORM_ARCH }}
          imageLabels: |
            quay.expires-after=${{ env.EXPIRES_AFTER }}
            org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}
          push: true
          platform: ${{ env.PLATFORM }}

      - name: Export digest (for :next builds)
        id: export-digest-next
        if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-next.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Export digest (for releases)
        id: export-digest-release
        if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-release.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
      runs-on: ubuntu-latest
      needs:
        - build-image
      env:
        HAS_QUAY_AUTH: ${{ secrets.QUAY_USERNAME != '' && secrets.QUAY_TOKEN != '' }}
      steps:
        - name: Prepare
          run: |
            ref_name=${{ github.ref_name }}
            if [ "$ref_name" == "main" ]; then
              ref_name="next"
            elif [[ "$ref_name" =~ ^release-([0-9]+)\.([0-9]+) ]]; then
              # next-1.y
              ref_name="next-${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            fi
            ref_name_short="${ref_name}"

            # for releases only
            if [[ $ref_name != "next" ]] && [[ $ref_name != "next-"* ]]; then
              # shorten from 1.6.1 => 1.6
              ref_name_short="${ref_name%.*}"
              if [[ $ref_name_short == "1" ]]; then ref_name_short="${ref_name}"; fi
            fi
            echo "REF_NAME=$ref_name" >> $GITHUB_ENV
            echo "REF_NAME_SHORT=${ref_name_short}" >> $GITHUB_ENV

            # compute expiry once and reuse
            if [[ "$ref_name_short" == "next" ]] || [[ "$ref_name_short" == next-* ]]; then
              expires_after="14d"  # Short expiry for next builds
            elif [[ "$ref_name_short" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              expires_after="183d" # Long expiry for official releases (1.2, 1.2.3, etc.)
            else
              expires_after="14d"  # Short expiry for feature branches and other temporary builds
            fi
            echo "EXPIRES_AFTER=$expires_after" >> $GITHUB_ENV

            # allow overriding target image when manually dispatched for testing
            if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.registry_image }}" ]; then
              echo "REGISTRY_IMAGE=${{ inputs.registry_image }}" >> $GITHUB_ENV
              echo "Using test registry: ${{ inputs.registry_image }}"
            fi

        - name: Check Quay credentials
          run: |
            if [ "${{ env.HAS_QUAY_AUTH }}" != "true" ]; then
              echo "::error::Missing QUAY_USERNAME or QUAY_TOKEN secrets"
              exit 1
            fi
            echo "✓ Quay credentials are available"

        - name: Checkout
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Download digests
          uses: actions/download-artifact@v4
          with:
            path: /tmp/digests
            pattern: digests-*
            merge-multiple: true

        - name: Get the last commit short SHA
          uses: ./.github/actions/get-sha

        - name: Set up Docker Buildx
          uses: docker/setup-buildx-action@v3

        - name: Set container metadata (for :next builds, 14d expiry)
          id: meta-next
          if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
          uses: docker/metadata-action@v5
          with:
            images: ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}
            tags: |
              type=raw,value=${{ env.REF_NAME }}
              type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}
            labels: |
              quay.expires-after=${{ env.EXPIRES_AFTER }}
              org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}

        - name: Set container metadata (for releases, 183d expiry)
          id: meta-release
          if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
          uses: docker/metadata-action@v5
          with:
            images: ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}
            tags: |
              type=raw,value=${{ env.REF_NAME }}
              type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}
              type=raw,value=${{ env.REF_NAME_SHORT }}
              type=raw,value=${{ env.REF_NAME_SHORT }}-${{ env.SHORT_SHA }}
            labels: |
              quay.expires-after=${{ env.EXPIRES_AFTER }}
              org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}

        - name: Login to Docker Hub
          uses: docker/login-action@v3
          with:
            registry: ${{ env.REGISTRY }}
            username: ${{ secrets.QUAY_USERNAME }}
            password: ${{ secrets.QUAY_TOKEN }}

        - name: Create manifest list and push
          working-directory: /tmp/digests
          run: |
            # Read tags from the metadata JSON of the step that ran
            meta='${{ steps.meta-release.outputs.json }}'
            if [ -z "$meta" ] || [ "$meta" = "null" ]; then
              meta='${{ steps.meta-next.outputs.json }}'
            fi

            # Create and annotate the manifest list for EACH tag to ensure Quay applies expiry per tag
            echo "$meta" | jq -r '.tags | unique[]' | while IFS= read -r tag; do
              [ -z "$tag" ] && continue
              docker buildx imagetools create \
                --annotation "quay.expires-after=${EXPIRES_AFTER}" \
                -t "$tag" \
                $(printf '${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}@sha256:%s ' *)
            done

        - name: Inspect image (for :next builds)
          id: inspect-next
          if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
          run: |
            docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}:${{ steps.meta-next.outputs.version }}

        - name: Inspect image (for releases)
          id: inspect-release
          if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
          run: |
            docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}:${{ steps.meta-release.outputs.version }}

        - name: Clean up per-arch images and ensure expiry on multi-arch tags
          if: env.HAS_QUAY_AUTH == 'true' && (github.event_name != 'workflow_dispatch' || inputs.test_cleanup == 'true')
          env:
            REGISTRY_IMAGE: ${{ env.REGISTRY_IMAGE }}
            REF_NAME: ${{ env.REF_NAME }}
            SHORT_SHA: ${{ env.SHORT_SHA }}
            EXPIRES_AFTER: ${{ env.EXPIRES_AFTER }}
            QUAY_USERNAME: ${{ secrets.QUAY_USERNAME }}
            QUAY_TOKEN: ${{ secrets.QUAY_TOKEN }}
          run: |
            set -e
            echo "Cleaning up temporary per-arch images and ensuring expiry on multi-arch tags..."
            
            # Sanitize REF_NAME for use in tags (replace '/' with '-')
            SAFE_REF_TAG="${REF_NAME//\//-}"
            
            # Calculate expiry timestamp
            expires="${EXPIRES_AFTER}"
            days="${expires%d}"
            if [[ "$expires" != *d ]] || ! [[ "$days" =~ ^[0-9]+$ ]]; then
              echo "::warning::Unknown EXPIRES_AFTER format: $EXPIRES_AFTER; defaulting to 14d"
              days=14
            fi
            expiry_ts=$(date -d "+${days} days" +%s)
            echo "Using expiry timestamp: ${expiry_ts} ($(date -d "@$expiry_ts"))"
            
            # Note: Robot accounts cannot get CSRF tokens for Quay API operations
            # Reference: https://github.com/operator-framework/operator-courier/issues/191
            echo "ℹ️  Robot accounts cannot use Quay API for destructive operations (CSRF limitation since 2020)"
            echo "ℹ️  Using Docker BuildX annotations instead of Quay API calls"
            
            # Multi-arch tags that should have expiry set
            multi_arch_tags=(
              "${SAFE_REF_TAG}"
              "${SAFE_REF_TAG}-${SHORT_SHA}"
            )
            
            echo "Re-applying expiry annotations to multi-arch tags: ${multi_arch_tags[*]}"
            for tag in "${multi_arch_tags[@]}"; do
              echo "Re-annotating tag: ${tag}"
              
              # Use docker buildx imagetools to re-annotate with expiry (bypasses CSRF requirement)
              # Reference: https://github.com/operator-framework/operator-courier/issues/191
              # Robot accounts cannot get CSRF tokens for Quay API operations since 2020
              echo "Applying expiry via Docker annotations (robot accounts cannot use Quay API)"
              if docker buildx imagetools create \
                --tag "${{ env.REGISTRY }}/${REGISTRY_IMAGE}:${tag}" \
                --annotation "quay.expires-after=${EXPIRES_AFTER}" \
                --annotation "org.opencontainers.image.expires=${EXPIRES_AFTER}" \
                --annotation "expires-after=${EXPIRES_AFTER}" \
                --annotation "quay.expires_after=${EXPIRES_AFTER}" \
                --annotation "index:quay.expires-after=${EXPIRES_AFTER}" \
                --annotation "manifest:quay.expires-after=${EXPIRES_AFTER}" \
                "${{ env.REGISTRY }}/${REGISTRY_IMAGE}:${tag}"; then
                echo "✓ Expiry annotations applied to: ${tag}"
                
                # Verify expiry was set by checking image manifest
                echo "Verifying expiry annotation..."
                docker buildx imagetools inspect "${{ env.REGISTRY }}/${REGISTRY_IMAGE}:${tag}" | grep -i "expires\|expiry" || echo "⚠️  No expiry found in manifest"
              else
                echo "::warning::Failed to re-annotate ${tag}"
              fi
            done
            
            # List of per-arch tags to delete
            per_arch_tags=(
              "${SAFE_REF_TAG}-amd64"
              "${SAFE_REF_TAG}-arm64"
              "${SAFE_REF_TAG}-${SHORT_SHA}-amd64"
              "${SAFE_REF_TAG}-${SHORT_SHA}-arm64"
            )
            
            echo "Per-arch tags to clean up: ${per_arch_tags[*]}"
            
            echo "✅ All tags processed using Docker BuildX annotations (CSRF-free approach)"
            echo "🕐 Per-arch images have expiry set and will be automatically cleaned up in 14 days"
            echo "ℹ️  Robot accounts cannot delete via API (Quay security limitation since 2020)"
            echo "ℹ️  For immediate cleanup: use Quay.io web UI or wait for natural expiry"
            
            rm -f /tmp/delete_resp.txt /tmp/expiry_resp.txt
            echo "Cleanup and expiry enforcement completed"
