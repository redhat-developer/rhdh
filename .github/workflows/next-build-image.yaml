# Copyright Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Build Next and Tag Image

on:
  # workflow_dispatch so that it can be triggered manually if needed
  workflow_dispatch:
    inputs:
      registry_image:
        description: "Target registry/repository (e.g., polasudo/testing)"
        required: false
        default: "polasudo/testing"
      test_cleanup:
        description: "Enable cleanup testing (true/false)"
        required: false
        default: "true"
  schedule:
    # run at 3:18 UTC every day
    - cron: "18 3 * * *"

  # in addition to building multi-arch :next images daily,
  # also build multi-arch images for any x.y or x.y.z tag pushed to the repo
  push:
    tags:
      - '[0-9]+.[0-9]+.[0-9]+'
      - '[0-9]+.[0-9]+'
    branches:
      - 'release-**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: quay.io
  REGISTRY_IMAGE: polasudo/testing

jobs:
  build-image:
    name: Build Image
    env:
      HAS_QUAY_AUTH: ${{ secrets.QUAY_USERNAME != '' && secrets.QUAY_TOKEN != '' }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-24.04-arm
          - ubuntu-24.04
    runs-on: ${{ matrix.os }}
    timeout-minutes: 720 # Set to 12 hours instead of default 360 = 6hrs
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare
        run: |
          if [ "${{ matrix.os }}" == "ubuntu-24.04" ]; then
            platform="linux/amd64"
          elif [ "${{ matrix.os }}" == "ubuntu-24.04-arm" ]; then
            platform="linux/arm64"
          else
            echo "Unknown platform"
            exit 1
          fi

          ref_name=${{ github.ref_name }}
          if [ "$ref_name" == "main" ]; then
            ref_name="next"
          elif [[ "$ref_name" =~ ^release-([0-9]+)\.([0-9]+) ]]; then
            # next-1.y
            ref_name="next-${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
          fi
          ref_name_short="${ref_name}"

          # for releases only
          if [[ $ref_name != "next" ]] && [[ $ref_name != "next-"* ]]; then
            # shorten from 1.6.1 => 1.6
            ref_name_short="${ref_name%.*}"
            if [[ $ref_name_short == "1" ]]; then ref_name_short="${ref_name}"; fi
          fi

          echo "REF_NAME=$ref_name" >> $GITHUB_ENV
          echo "REF_NAME_SHORT=${ref_name_short}" >> $GITHUB_ENV
          echo "PLATFORM=$platform" >> $GITHUB_ENV
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV
          echo "PLATFORM_ARCH=${platform#*/}" >> $GITHUB_ENV

          # compute expiry once and reuse
          if [[ "$ref_name_short" == "next" ]] || [[ "$ref_name_short" == next-* ]]; then
            expires_after="14d"  # Short expiry for next builds
          elif [[ "$ref_name_short" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
            expires_after="183d" # Long expiry for official releases (1.2, 1.2.3, etc.)
          else
            expires_after="14d"  # Short expiry for feature branches and other temporary builds
          fi
          echo "EXPIRES_AFTER=$expires_after" >> $GITHUB_ENV

          # allow overriding target image when manually dispatched for testing
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.registry_image }}" ]; then
            echo "REGISTRY_IMAGE=${{ inputs.registry_image }}" >> $GITHUB_ENV
            echo "Using test registry: ${{ inputs.registry_image }}"
          fi

      - name: Check Quay credentials
        run: |
          if [ "${{ env.HAS_QUAY_AUTH }}" != "true" ]; then
            echo "::error::Missing QUAY_USERNAME or QUAY_TOKEN secrets"
            exit 1
          fi
          echo "✓ Quay credentials are available"

      - name: Login to Quay
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}

      - name: Get the last commit short SHA
        uses: ./.github/actions/get-sha

      - name: Build and Push with Buildx (for :next builds, 14d expiry)
        uses: ./.github/actions/docker-build
        id: build-next
        if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
          imageName: ${{ env.REGISTRY_IMAGE }}
          imageTags: |
            type=raw,value=${{ env.REF_NAME }}-${{ env.PLATFORM_ARCH }}
            type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}-${{ env.PLATFORM_ARCH }}
          imageLabels: |
            quay.expires-after=${{ env.EXPIRES_AFTER }}
            org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}
          push: true
          platform: ${{ env.PLATFORM }}

      - name: Build and Push with Buildx (for releases, 183d expiry)
        uses: ./.github/actions/docker-build
        id: build-release
        if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
          imageName: ${{ env.REGISTRY_IMAGE }}
          imageTags: |
            type=raw,value=${{ env.REF_NAME }}-${{ env.PLATFORM_ARCH }}
            type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}-${{ env.PLATFORM_ARCH }}
          imageLabels: |
            quay.expires-after=${{ env.EXPIRES_AFTER }}
            org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}
          push: true
          platform: ${{ env.PLATFORM }}

      - name: Export digest (for :next builds)
        id: export-digest-next
        if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-next.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Export digest (for releases)
        id: export-digest-release
        if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-release.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
      runs-on: ubuntu-latest
      needs:
        - build-image
      env:
        HAS_QUAY_AUTH: ${{ secrets.QUAY_USERNAME != '' && secrets.QUAY_TOKEN != '' }}
      steps:
        - name: Prepare
          run: |
            ref_name=${{ github.ref_name }}
            if [ "$ref_name" == "main" ]; then
              ref_name="next"
            elif [[ "$ref_name" =~ ^release-([0-9]+)\.([0-9]+) ]]; then
              # next-1.y
              ref_name="next-${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            fi
            ref_name_short="${ref_name}"

            # for releases only
            if [[ $ref_name != "next" ]] && [[ $ref_name != "next-"* ]]; then
              # shorten from 1.6.1 => 1.6
              ref_name_short="${ref_name%.*}"
              if [[ $ref_name_short == "1" ]]; then ref_name_short="${ref_name}"; fi
            fi
            echo "REF_NAME=$ref_name" >> $GITHUB_ENV
            echo "REF_NAME_SHORT=${ref_name_short}" >> $GITHUB_ENV

            # compute expiry once and reuse
            if [[ "$ref_name_short" == "next" ]] || [[ "$ref_name_short" == next-* ]]; then
              expires_after="14d"  # Short expiry for next builds
            elif [[ "$ref_name_short" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
              expires_after="183d" # Long expiry for official releases (1.2, 1.2.3, etc.)
            else
              expires_after="14d"  # Short expiry for feature branches and other temporary builds
            fi
            echo "EXPIRES_AFTER=$expires_after" >> $GITHUB_ENV

            # allow overriding target image when manually dispatched for testing
            if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.registry_image }}" ]; then
              echo "REGISTRY_IMAGE=${{ inputs.registry_image }}" >> $GITHUB_ENV
              echo "Using test registry: ${{ inputs.registry_image }}"
            fi

        - name: Check Quay credentials
          run: |
            if [ "${{ env.HAS_QUAY_AUTH }}" != "true" ]; then
              echo "::error::Missing QUAY_USERNAME or QUAY_TOKEN secrets"
              exit 1
            fi
            echo "✓ Quay credentials are available"

        - name: Checkout
          uses: actions/checkout@v4
          with:
            fetch-depth: 0

        - name: Download digests
          uses: actions/download-artifact@v4
          with:
            path: /tmp/digests
            pattern: digests-*
            merge-multiple: true

        - name: Get the last commit short SHA
          uses: ./.github/actions/get-sha

        - name: Set up Docker Buildx
          uses: docker/setup-buildx-action@v3

        - name: Set container metadata (for :next builds, 14d expiry)
          id: meta-next
          if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
          uses: docker/metadata-action@v5
          with:
            images: ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}
            tags: |
              type=raw,value=${{ env.REF_NAME }}
              type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}
            labels: |
              quay.expires-after=${{ env.EXPIRES_AFTER }}
              org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}

        - name: Set container metadata (for releases, 183d expiry)
          id: meta-release
          if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
          uses: docker/metadata-action@v5
          with:
            images: ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}
            tags: |
              type=raw,value=${{ env.REF_NAME }}
              type=raw,value=${{ env.REF_NAME }}-${{ env.SHORT_SHA }}
              type=raw,value=${{ env.REF_NAME_SHORT }}
              type=raw,value=${{ env.REF_NAME_SHORT }}-${{ env.SHORT_SHA }}
            labels: |
              quay.expires-after=${{ env.EXPIRES_AFTER }}
              org.opencontainers.image.expires=${{ env.EXPIRES_AFTER }}

        - name: Login to Docker Hub
          uses: docker/login-action@v3
          with:
            registry: ${{ env.REGISTRY }}
            username: ${{ secrets.QUAY_USERNAME }}
            password: ${{ secrets.QUAY_TOKEN }}

        - name: Create manifest list and push
          working-directory: /tmp/digests
          run: |
            # Read tags from the metadata JSON of the step that ran
            meta='${{ steps.meta-release.outputs.json }}'
            if [ -z "$meta" ] || [ "$meta" = "null" ]; then
              meta='${{ steps.meta-next.outputs.json }}'
            fi

            # Create and annotate the manifest list for EACH tag to ensure Quay applies expiry per tag
            echo "$meta" | jq -r '.tags | unique[]' | while IFS= read -r tag; do
              [ -z "$tag" ] && continue
              docker buildx imagetools create \
                --annotation "quay.expires-after=${EXPIRES_AFTER}" \
                -t "$tag" \
                $(printf '${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}@sha256:%s ' *)
            done

        - name: Inspect image (for :next builds)
          id: inspect-next
          if: ${{ env.REF_NAME_SHORT == 'next' || startsWith(env.REF_NAME_SHORT,'next-') }}
          run: |
            docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}:${{ steps.meta-next.outputs.version }}

        - name: Inspect image (for releases)
          id: inspect-release
          if: ${{ env.REF_NAME_SHORT != 'next' && !startsWith(env.REF_NAME_SHORT,'next-') }}
          run: |
            docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.REGISTRY_IMAGE }}:${{ steps.meta-release.outputs.version }}

        - name: Clean up per-arch images and ensure expiry on multi-arch tags
          if: env.HAS_QUAY_AUTH == 'true' && (github.event_name != 'workflow_dispatch' || inputs.test_cleanup == 'true')
          env:
            REGISTRY_IMAGE: ${{ env.REGISTRY_IMAGE }}
            REF_NAME: ${{ env.REF_NAME }}
            SHORT_SHA: ${{ env.SHORT_SHA }}
            EXPIRES_AFTER: ${{ env.EXPIRES_AFTER }}
            QUAY_USERNAME: ${{ secrets.QUAY_USERNAME }}
            QUAY_TOKEN: ${{ secrets.QUAY_TOKEN }}
          run: |
            set -e
            echo "Cleaning up temporary per-arch images and ensuring expiry on multi-arch tags..."
            
            # Sanitize REF_NAME for use in tags (replace '/' with '-')
            SAFE_REF_TAG="${REF_NAME//\//-}"
            
            # Calculate expiry timestamp
            expires="${EXPIRES_AFTER}"
            days="${expires%d}"
            if [[ "$expires" != *d ]] || ! [[ "$days" =~ ^[0-9]+$ ]]; then
              echo "::warning::Unknown EXPIRES_AFTER format: $EXPIRES_AFTER; defaulting to 14d"
              days=14
            fi
            expiry_ts=$(date -d "+${days} days" +%s)
            echo "Using expiry timestamp: ${expiry_ts} ($(date -d "@$expiry_ts"))"
            
            # Prepare Basic Auth for robot account (username:token encoded as base64)
            echo "Setting up robot account authentication..."
            auth_string="${QUAY_USERNAME}:${QUAY_TOKEN}"
            auth_header="Authorization: Basic $(echo -n "$auth_string" | base64 -w 0)"
            echo "✓ Robot account authentication configured"
            
            # Get CSRF token for robot account (required for PUT/DELETE operations)
            echo "Fetching CSRF token for robot account..."
            csrf_response=$(curl -sS -H "$auth_header" \
              "https://quay.io/api/v1/user/" 2>/dev/null || echo "{}")
            
            echo "DEBUG: API response: $csrf_response"
            
            # Try multiple ways to extract CSRF token
            csrf_token=$(echo "$csrf_response" | jq -r '.csrf_token // empty' 2>/dev/null || echo "")
            
            if [ -z "$csrf_token" ] || [ "$csrf_token" = "null" ] || [ "$csrf_token" = "empty" ]; then
              # Try alternative CSRF token field names
              csrf_token=$(echo "$csrf_response" | jq -r '.csrfToken // empty' 2>/dev/null || echo "")
            fi
            
            if [ -z "$csrf_token" ] || [ "$csrf_token" = "null" ] || [ "$csrf_token" = "empty" ]; then
              # Try to get CSRF token from response headers
              echo "Trying to get CSRF token from headers..."
              csrf_token=$(curl -sS -I -H "$auth_header" \
                "https://quay.io/api/v1/user/" 2>/dev/null | grep -i "x-csrf-token\|csrf-token" | cut -d: -f2 | tr -d ' \r\n' || echo "")
              echo "DEBUG: CSRF token from headers: '$csrf_token'"
            fi
            
            if [ -z "$csrf_token" ] || [ "$csrf_token" = "null" ] || [ "$csrf_token" = "empty" ]; then
              # Try to get CSRF token from a different endpoint
              echo "Trying alternative CSRF token endpoint..."
              csrf_response2=$(curl -sS -H "$auth_header" \
                "https://quay.io/api/v1/repository/${REGISTRY_IMAGE}" 2>/dev/null || echo "{}")
              echo "DEBUG: Repository API response: $csrf_response2"
              csrf_token=$(echo "$csrf_response2" | jq -r '.csrf_token // .csrfToken // empty' 2>/dev/null || echo "")
            fi
            
            if [ -n "$csrf_token" ] && [ "$csrf_token" != "null" ] && [ "$csrf_token" != "empty" ]; then
              echo "✓ CSRF token obtained: ${csrf_token}"
              csrf_header="-H X-CSRFToken:${csrf_token}"
            else
              echo "::warning::Could not obtain CSRF token - API calls may fail"
              csrf_header=""
            fi
            
            # Multi-arch tags that should have expiry set
            multi_arch_tags=(
              "${SAFE_REF_TAG}"
              "${SAFE_REF_TAG}-${SHORT_SHA}"
            )
            
            echo "Re-applying expiry annotations to multi-arch tags: ${multi_arch_tags[*]}"
            for tag in "${multi_arch_tags[@]}"; do
              echo "Re-annotating tag: ${tag}"
              
              # Use docker buildx imagetools to re-annotate with expiry (bypasses CSRF requirement)
              docker buildx imagetools create \
                --tag "${{ env.REGISTRY }}/${REGISTRY_IMAGE}:${tag}" \
                --annotation "quay.expires-after=${EXPIRES_AFTER}" \
                --annotation "org.opencontainers.image.expires=${EXPIRES_AFTER}" \
                --annotation "expires-after=${EXPIRES_AFTER}" \
                --annotation "quay.expires_after=${EXPIRES_AFTER}" \
                "${{ env.REGISTRY }}/${REGISTRY_IMAGE}:${tag}" && echo "✓ Expiry annotations applied to: ${tag}" || echo "::warning::Failed to re-annotate ${tag}"
            done
            
            # List of per-arch tags to delete
            per_arch_tags=(
              "${SAFE_REF_TAG}-amd64"
              "${SAFE_REF_TAG}-arm64"
              "${SAFE_REF_TAG}-${SHORT_SHA}-amd64"
              "${SAFE_REF_TAG}-${SHORT_SHA}-arm64"
            )
            
            echo "Per-arch tags to clean up: ${per_arch_tags[*]}"
            
            echo "Per-arch images already have expiry set and will be automatically cleaned up."
            echo "Skipping immediate deletion to avoid CSRF token issues with robot accounts."
            echo "If immediate cleanup is needed, this can be done manually via Quay.io web UI."
            
            # Optional: Try to delete per-arch tags (best effort, ignore failures)
            if [ "${EXPIRES_AFTER}" = "14d" ]; then
              echo "Attempting best-effort cleanup of per-arch images..."
              for tag in "${per_arch_tags[@]}"; do
                echo "Trying to delete: ${tag}"
                curl -sS -H "$auth_header" -X DELETE \
                  "https://quay.io/api/v1/repository/${REGISTRY_IMAGE}/tag/${tag}" >/dev/null 2>&1 && \
                  echo "  ✓ Deleted: ${tag}" || echo "  ℹ️  Could not delete: ${tag} (will expire naturally)"
              done
            fi
            
            rm -f /tmp/delete_resp.txt /tmp/expiry_resp.txt
            echo "Cleanup and expiry enforcement completed"
