name: "Check Image and Relevant Changes"
description: "Checks if the image already exists and if changes are relevant"

outputs:
  image_exists:
    description: "True if the image already exists"
    value: ${{ steps.image-check.outputs.exists }}
  relevant_changes:
    description: "True if changes require a build"
    value: ${{ steps.changes.outputs.relevant }}
  is_skipped:
    description: "True if build should be skipped (via [skip-build] tag OR image exists with no relevant changes)"
    value: ${{ steps.final-decision.outputs.is_skipped }}
  short_sha:
    description: "Short SHA of the latest commit"
    value: ${{ steps.get-sha.outputs.short_sha }}

runs:
  using: "composite"
  steps:
    - name: Get the last commit short SHA
      id: get-sha
      uses: ./.github/actions/get-sha

    - name: Check for relevant changes
      id: changes
      shell: bash
      run: |
        echo "ðŸ” Checking changes and build requirements..."
        
        # Function to check if file is in always-skip paths
        check_always_skip_paths() {
          local file=$1
          local patterns=("docs/*" "*.md")
          for pattern in "${patterns[@]}"; do
            [[ "$file" == $pattern ]] && return 0
          done
          return 1  # false - don't skip automatically
        }
        
        # Function to check if file is in image-dependent paths
        check_image_dependent_paths() {
          local file=$1
          local patterns=("e2e/*" "e2e-tests/*" ".ibm/*" ".rhdh/docker/*")
          for pattern in "${patterns[@]}"; do
            [[ "$file" == $pattern ]] && return 0
          done
          return 1  # false - doesn't need image
        }
        
        # Function to check if file is relevant code for build
        check_relevant_code() {
          local file=$1
          # Files that affect application build
          local patterns=("packages/*" "plugins/*" "dynamic-plugins/*" "app-config*.yaml" "catalog-entities/*" "docker/*" "Dockerfile*" "package*.json" "yarn.lock" "tsconfig*.json")
          for pattern in "${patterns[@]}"; do
            [[ "$file" == $pattern ]] && return 0
          done
          return 1  # false - not relevant code
        }
        
        # Search for commits with [skip-build] or [skip build] tag
        echo "ðŸ·ï¸  Checking commits with [skip-build] tag..."
        SKIP_COMMITS=$(git log --format="%H %s" origin/main..HEAD | grep -i "\[skip[- ]build\]" | wc -l)
        
        if [ "$SKIP_COMMITS" -gt 0 ]; then
          echo "âœ… Found $SKIP_COMMITS commits with [skip-build] tag"
        else
          echo "âŒ No commits with [skip-build] tag found"
        fi
        
        # Get changed files
        echo "ðŸ“ Getting list of changed files..."
        CHANGED_FILES=$(git diff --name-only origin/main..HEAD)
        
        if [ -z "$CHANGED_FILES" ]; then
          echo "âš ï¸  No changed files found"
          echo "SKIP_BUILD=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "ðŸ“‹ Changed files:"
        echo "$CHANGED_FILES" | while read -r file; do
          echo "  - $file"
        done
        
        # Classify files - use while loop without pipe to avoid subshell
        ALWAYS_SKIP_FILES=""
        IMAGE_DEPENDENT_FILES=""
        RELEVANT_CODE_FILES=""
        OTHER_FILES=""
        
        while IFS= read -r file; do
          if [ -n "$file" ]; then
            if check_always_skip_paths "$file"; then
              ALWAYS_SKIP_FILES="$ALWAYS_SKIP_FILES $file"
            elif check_image_dependent_paths "$file"; then
              IMAGE_DEPENDENT_FILES="$IMAGE_DEPENDENT_FILES $file"
            elif check_relevant_code "$file"; then
              RELEVANT_CODE_FILES="$RELEVANT_CODE_FILES $file"
            else
              OTHER_FILES="$OTHER_FILES $file"
            fi
          fi
        done <<< "$CHANGED_FILES"
        
        echo "ðŸ” File classification:"
        if [ -n "$ALWAYS_SKIP_FILES" ]; then
          echo "ðŸ“„ Always skip files (docs, *.md): $ALWAYS_SKIP_FILES"
        fi
        if [ -n "$IMAGE_DEPENDENT_FILES" ]; then
          echo "ðŸ§ª Image-dependent files (e2e, tests): $IMAGE_DEPENDENT_FILES"
        fi
        if [ -n "$RELEVANT_CODE_FILES" ]; then
          echo "ðŸ’» Relevant code files: $RELEVANT_CODE_FILES"
        fi
        if [ -n "$OTHER_FILES" ]; then
          echo "ðŸ“¦ Other files: $OTHER_FILES"
        fi
        
        # Decision logic
        SHOULD_SKIP=false
        
        # If relevant code changed, never skip
        if [ -n "$RELEVANT_CODE_FILES" ]; then
          echo "ðŸ”¥ Relevant code changed - build required"
          SHOULD_SKIP=false
        # If commits have [skip-build], try to skip
        elif [ "$SKIP_COMMITS" -gt 0 ]; then
          echo "ðŸ·ï¸  [skip-build] tag found - checking if safe to skip..."
          
          # If only always-skip files, can skip
          if [ -z "$IMAGE_DEPENDENT_FILES" ] && [ -z "$OTHER_FILES" ]; then
            echo "âœ… Only docs/md files changed - can skip build"
            SHOULD_SKIP=true
          # If image-dependent files present, check if image exists
          elif [ -n "$IMAGE_DEPENDENT_FILES" ]; then
            echo "ðŸ§ª Image-dependent files changed - checking if image exists..."
            
            # Check if Docker image exists in Quay.io registry
            PR_NUMBER="${{ github.event.number }}"
            if [ -z "$PR_NUMBER" ]; then
              echo "âš ï¸  PR number not found, forcing build"
              SHOULD_SKIP=false
            else
              # Check if image exists in Quay.io registry using API
              IMAGE_TAG="pr-$PR_NUMBER"
              REGISTRY_URL="https://quay.io/api/v1/repository/rhdh-community/rhdh/tag/$IMAGE_TAG"
              
              echo "ðŸ” Checking if image exists in Quay.io: $IMAGE_TAG"
              echo "ðŸŒ Registry API URL: $REGISTRY_URL"
              
              # Use curl to check if tag exists in Quay.io
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$REGISTRY_URL" || echo "000")
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "âœ… Image found in Quay.io registry - can skip build"
                SHOULD_SKIP=true
              elif [ "$HTTP_STATUS" = "404" ]; then
                echo "âŒ Image not found in Quay.io registry - build required"
                SHOULD_SKIP=false
              else
                echo "âš ï¸  Unable to verify image in registry (HTTP $HTTP_STATUS) - forcing build for safety"
                SHOULD_SKIP=false
              fi
            fi
          else
            echo "âœ… Only other files changed - can skip build"
            SHOULD_SKIP=true
          fi
        else
          echo "âŒ No [skip-build] tag found - build required"
          SHOULD_SKIP=false
        fi
        
        # Final result
        if [ "$SHOULD_SKIP" = true ]; then
          echo "ðŸŽ‰ DECISION: SKIP BUILD"
          echo "is_skipped=true" >> $GITHUB_OUTPUT
        else
          echo "ðŸš€ DECISION: EXECUTE BUILD"
          echo "is_skipped=false" >> $GITHUB_OUTPUT
        fi

    - name: Set final skip decision
      id: final-decision
      shell: bash
      run: |
        echo "ðŸ“Š Defining final decision based on previous analysis..."
        
        # Get the decision from the previous step
        IS_SKIPPED="${{ steps.changes.outputs.is_skipped }}"
        
        if [ "$IS_SKIPPED" = "true" ]; then
          echo "ðŸŽ‰ FINAL DECISION: SKIP BUILD"
          echo "is_skipped=true" >> $GITHUB_OUTPUT
        else
          echo "ðŸš€ FINAL DECISION: EXECUTE BUILD"
          echo "is_skipped=false" >> $GITHUB_OUTPUT
        fi
