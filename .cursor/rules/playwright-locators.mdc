---
description: Best practices for using Playwright locators in RHDH e2e tests
globs: e2e-tests/**
---

# Playwright Locator Best Practices

## Locator Priority (Use in Order)

1. **`page.getByRole(role, { name })`** - Interactive elements, headings (reflects user perception)
2. **`page.getByLabel(text)`** - Form controls with labels
3. **`page.getByPlaceholder(text)`** - Inputs without labels
4. **`page.getByText(text)`** - Non-interactive content only
5. **`page.getByAltText(text)`** - Images
6. **`page.getByTitle(text)`** - Elements with title attribute
7. **`page.getByTestId(id)`** - Last resort when semantic locators unavailable
8. **`page.locator(selector)`** - Avoid CSS/XPath unless necessary

## Quick Examples

```typescript
// ✅ GOOD - Semantic locators
await page.getByRole('button', { name: 'Submit' }).click();
await page.getByLabel('Username').fill('admin');
await page.getByPlaceholder('Search...').type('test');
await expect(page.getByText('Welcome')).toBeVisible();

// ✅ GOOD - Filtering and chaining
await page.getByRole('row')
  .filter({ hasText: 'Guest User' })
  .getByRole('button', { name: 'Edit' })
  .click();

// ❌ BAD - Implementation-dependent selectors
await page.locator('.MuiButton-label').click();
await page.locator('div:nth-child(3)').click();
await page.locator('//*[@id="form"]/div[2]/input').fill('test');
```

## Anti-Patterns

- ❌ CSS class selectors (`.MuiButton-label`, `[class*="MuiTableCell"]`)
- ❌ Long XPath chains
- ❌ `nth-child` without semantic context
- ❌ Using `force: true` to bypass checks
- ❌ Mixing locator strategies inconsistently

## Filtering & Chaining

```typescript
// Filter by text or child elements
const row = page.getByRole('listitem').filter({ hasText: 'Product 2' });
const card = page.getByRole('article').filter({ 
  has: page.getByRole('button', { name: 'Delete' }) 
});

// Narrow scope with chaining
await page.getByTestId('dialog')
  .getByRole('button', { name: 'OK' })
  .click();

// Handle alternatives with .or()
const btn = page.getByRole('button', { name: 'New' });
const dialog = page.getByText('Confirm settings');
await expect(btn.or(dialog).first()).toBeVisible();
```

## Page Objects

```typescript
// ✅ Return locators, not elements
class CatalogPage {
  constructor(private page: Page) {}

  getSearchInput(): Locator {
    return this.page.getByPlaceholder('Search');
  }

  getComponentLink(name: string): Locator {
    return this.page.getByRole('link', { name });
  }

  async findComponent(searchTerm: string): Promise<void> {
    await this.getSearchInput().fill(searchTerm);
    await this.getSearchInput().press('Enter');
  }
}
```

## Debugging

```bash
# Generate locators automatically
npx playwright codegen http://localhost:7007

# Debug tests step-by-step
npx playwright test --debug

# Or pause in test
await page.pause();
```

## Resources

- **Full Guide**: `docs/e2e-tests/playwright-locator-best-practices.md`
- **Official Docs**: https://playwright.dev/docs/locators
- **Best Practices**: https://playwright.dev/docs/best-practices

## Remember

Good locators reflect how users interact with your app. Ask: "How would a user or screen reader find this element?"
