- name: Create custom resource directory
  ansible.builtin.file:
    path: "{{ orch_rhdh_config_dir }}"
    state: "{{ item }}"
  loop:
    - absent
    - directory

- name: Scale back Orchestrator Operator
  ansible.builtin.import_tasks: scale-back-operator.yaml
  when:
    - orch_install_rhdh|bool
    - not orch_go_operator|bool

- name: Set Dynamic Plugins from Orchestrator CRD
  ansible.builtin.import_tasks: set-dynamic-plugins.yaml

- name: Check if Orchestrator SA exists
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  ansible.builtin.shell: |
    oc -n orchestrator get secret/orchestrator -o jsonpath='{.data.token}'
  register: tmp_orch_sa_token
  failed_when: false

- name: Create Orchestrator sa with admin policy and k8s token
  when: tmp_orch_sa_token.rc != 0
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  block:
    - name: Create Orchestrator SA
      ansible.builtin.shell: |
        oc create sa orchestrator -n orchestrator

    - name: Add Orchestrator admin role
      ansible.builtin.shell: |
        oc adm policy add-cluster-role-to-user cluster-admin -z orchestrator -n orchestrator

    - name: Create Orchestrator SA k8s token
      ansible.builtin.shell: |
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Secret
        type: kubernetes.io/service-account-token
        metadata:
          name: orchestrator
          namespace: orchestrator
          annotations:
            kubernetes.io/service-account.name: orchestrator
        EOF

- name: Gather values required for Orchestrator configuration
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  block:
    - name: Get Keycloak route
      ansible.builtin.shell: |
        oc get routes -A -l app=keycloak -o json | jq '.items[0].spec.host' -r
      when: orch_keycloak_auth|bool
      register: keycloak_route
      failed_when: keycloak_route.stdout == ''

    - name: Check if Backstage CR exists (to decide if we should wait/capture route now)
      ansible.builtin.shell: |
        oc get backstages.rhdh.redhat.com -n {{ rhdh_ns }} --no-headers 2>/dev/null | wc -l
      register: backstage_cr_count
      changed_when: false
      failed_when: false

    - name: Wait for RHDH/Backstage deployment before capturing route
      ansible.builtin.shell: |
        # Aguarda CR Backstage Deployed=True, se existir
        oc wait backstages.rhdh.redhat.com --all -A --timeout=300s --for=condition=Deployed=True 2>/dev/null || true
        # Ou aguarda deployment com label do backstage ficar Available
        oc get deployment -A -l app=backstage -o name | xargs -r -I{} sh -c 'oc wait {} --for=condition=Available --timeout=300s' || true
      register: backstage_wait
      failed_when: false
      retries: 6
      delay: 20
      when: (backstage_cr_count.stdout | default('0') | int) > 0

    - name: Capture backstage route
      ansible.builtin.shell: |
        oc get routes -A -l app.kubernetes.io/name=backstage -o json | jq '.items[0].spec.host' -r
      register: backstage_route
      retries: 20
      delay: 30
      until: backstage_route.stdout != '' and backstage_route.stdout != 'null'
      failed_when: backstage_route.stdout == '' or backstage_route.stdout == 'null'
      when: (backstage_cr_count.stdout | default('0') | int) > 0

    - name: Capture orchestrator sa k8s token route
      ansible.builtin.shell: |
        oc whoami --show-server
      register: k8s_cluster_url

    - name: Get Orchestrator SA Token
      ansible.builtin.shell: |
        oc -n orchestrator get secret/orchestrator -o jsonpath='{.data.token}'
      register: orchestrator_sa

    - name: Capture Sonataflow data index service
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ansible.builtin.shell: |
        oc get svc -n sonataflow-infra sonataflow-platform-data-index-service -o jsonpath='http://{.metadata.name}.{.metadata.namespace}' 2>/dev/null || true
      register: sonataflow_data_index_svc
      retries: 30 # aguarda até 10 minutos (30×20s)
      delay: 20
      until: sonataflow_data_index_svc.stdout != ''
      failed_when: sonataflow_data_index_svc.stdout == ''

- name: Capture argocd values
  when: deploy_with_gitops|bool
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  block:
    - name: Get argocd route
      ansible.builtin.shell: |
        oc get route -n {{ gitops_namespace }} -l app.kubernetes.io/managed-by=argocd -ojsonpath='{.items[0].status.ingress[0].host}'
      register: argocd_route

    - name: Get argocd password
      ansible.builtin.shell: |
        oc get secret -n {{ gitops_namespace }} argocd-cluster -o json | jq -r '.data."admin.password"' | base64 -d
      register: argocd_pass

- name: Set backstage backend secret and recreate backstage-backend-auth-secret secret
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  block:
    - name: Capture backstage backend secret if it exists
      ansible.builtin.shell: |
        oc get secret backstage-backend-auth-secret -n {{ rhdh_ns }} -o jsonpath='{.data.BACKEND_SECRET}'
      register: tmp_backend_secret
      failed_when: false

    - name: Generate backend secret unless it already exists in backstage-backend-auth-secret secret
      vars:
        tmp_gen_secret: "{{  lookup('community.general.random_string', length=24, upper=true, lower=true, numbers=true, special=false) }}"
      ansible.builtin.set_fact:
        backstage_backend_secret: "{{ tmp_gen_secret if tmp_backend_secret.rc != 0 else (tmp_backend_secret.stdout|b64decode) }}"

    - name: Generate secrets file from template
      ansible.builtin.template:
        src: "backstage-backend-auth-secret.txt.j2"
        dest: "{{ orch_rhdh_config_dir }}/backstage-backend-auth-secret.txt"

    - name: Delete existing secret backstage-backend-auth-secret
      ansible.builtin.shell: |
        oc delete secret backstage-backend-auth-secret -n {{ rhdh_ns }}
      failed_when: false

    - name: Create new secret backstage-backend-auth-secret with manually identified variable values.
      ansible.builtin.shell: |
        oc create secret generic backstage-backend-auth-secret -n {{ rhdh_ns }} --from-env-file={{ orch_rhdh_config_dir }}/backstage-backend-auth-secret.txt

- name: Set fact for npmrc registry
  ansible.builtin.set_fact:
    orch_npmrc_registry_full: "registry={{ orch_npmrc_registry_options[orch_npmrc_registry] }}"

- name: Generate custom resources from templates
  ansible.builtin.template:
    src: "{{ item }}"
    dest: "{{ orch_rhdh_config_dir }}/{{ item[:-3] }}"
  loop:
    - app-config-rhdh.yaml.j2
    - app-config-auth.gh.yaml.j2
    - app-config-catalog.yaml.j2
    - backstage.yaml.j2
    - dynamic-plugins.yaml.j2
    - rbac-policy.csv.j2
    - dynamic-plugins-npmrc.yaml.j2

# https://stackoverflow.com/questions/51291521/kubernetes-configmap-prints-n-instead-of-a-newline
- name: Remove empty space before newline character of yaml files to keep configmap data formatting
  ansible.builtin.shell: |
    sed -i -E 's/[[:space:]]+$//g' {{ orch_rhdh_config_dir }}/*.*

- name: Create Configmaps from Config Files
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  ansible.builtin.shell: |
    oc create configmap {{ item['configmap'] }} -n {{ rhdh_ns }} --from-file="{{ item['configfile'] }}"={{ orch_rhdh_config_dir }}/{{ item['configfile'] }} || \
    oc set data cm/{{ item['configmap'] }} -n {{ rhdh_ns }} --from-file="{{ item['configfile'] }}"={{ orch_rhdh_config_dir }}/{{ item['configfile'] }}
  loop:
    - configmap: app-config-rhdh-auth
      configfile: app-config-auth.gh.yaml
    - configmap: app-config-rhdh-catalog
      configfile: app-config-catalog.yaml
    - configmap: app-config-rhdh
      configfile: app-config-rhdh.yaml
    - configmap: rhdh-config-rbac-policy
      configfile: rbac-policy.csv
    - configmap: dynamic-plugins-rhdh
      configfile: dynamic-plugins.yaml

- name: Apply custom resources
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  ansible.builtin.shell: |
    oc apply -f {{ orch_rhdh_config_dir }}/{{ item[:-3]  }}
  loop:
    - backstage.yaml.j2
    - dynamic-plugins-npmrc.yaml.j2
