# Deploy sonataflow 1.35 rc build resources - temporary
- name: Deploy Orchestrator Operator
  ansible.builtin.import_tasks: sonataflow-rc-tasks.yaml
  when: deploy_sf_rc_build | bool

# Note: Currently no method to differentiate between milestone version with iib - it just grabs latest found
- name: Query datagrepper for latest orchestrator index image (iib)
  block:
    - name: Query datagrepper
      vars:
        dg_contains: orchestrator-releng-tenant
        dg_topic: "/topic/VirtualTopic.eng.iib.build.state"
      ansible.builtin.import_tasks: tasks/query_datagrepper.yaml

    - name: Set orchestrator index image to latest iib image found
      vars:
        orch_iib_images: "{{ dg_msgs | selectattr('state', '==', 'complete') | map(attribute='index_image') }}"
        orch_op_index_image: "{{ orch_iib_images | first}}"
      ansible.builtin.set_fact:
        orch_op_tag: "{{ orch_op_index_image.split('/')[-1] }}"
        orch_op_index_image: "{{ orch_op_index_image }}"
  when:
    - deploy_operator_version == 'latest'
    - deploy_operator_source == 'iib'

- name: Find latest operator image from quay
  vars:
    quay_operator_repo: "{{ 'orchestrator-operator-catalog' if milestone|int <= 4 else 'orchestrator-go-operator-catalog'}}"
  block:
    - name: Capture operator tags
      ansible.builtin.uri:
        url: https://quay.io/api/v1/repository/orchestrator/{{ quay_operator_repo }}/tag/?limit=100&page={{ item }}&onlyActiveTags=true
        return_content: true
      register: raw_tags
      loop: "{{ range(1, 5) | list }}"

    - name: Create list of operator tags in descending order of creation
      vars:
        raw_tags_base: "{{ raw_tags.results | map(attribute='json') | map(attribute='tags') | list | flatten }}"
      ansible.builtin.set_fact:
        # Tags ordered by time stamp (Latest first)
        orch_op_tags: "{{ raw_tags_base | sort(attribute='start_ts', reverse=True) | map(attribute='name') | list }}"

    - name: Set Orchestrator operator tag based on milestone
      block:
        - name: Use specific milestone version
          when: milestone != 'latest'
          vars:
            matching_tags: "{{ orch_op_tags | select('match', '^v1\\.' + milestone + '\\..*') | list }}"
          ansible.builtin.set_fact:
            orch_op_tag: "{{ matching_tags | first | default('') }}"

        - name: Use latest available version
          when: milestone == 'latest' or orch_op_tag | default('') == ''
          ansible.builtin.set_fact:
            orch_op_tag: "{{ orch_op_tags | select('match', '^v1\\..*') | first | default(orch_op_tags | first) }}"

        - name: Fail if no tag found
          when: orch_op_tag | default('') == ''
          ansible.builtin.fail:
            msg: "No operator version found for milestone {{ milestone }}. Available tags: {{ orch_op_tags[:10] }}"

        - name: Set index image
          ansible.builtin.set_fact:
            orch_op_index_image: "quay.io/orchestrator/{{ quay_operator_repo }}:{{ orch_op_tag }}"

    - name: Debug out tag information
      debug:
        msg:
          - "Found the following available operator tags: {{ orch_op_tags }}"
          - "Tag to be used is {{ orch_op_tag }} and full index image is {{ orch_op_index_image }}"
          - "ORCHESTRATOR_OPERATOR_INDEX_IMAGE={{ orch_op_index_image }}"
  when:
    - deploy_operator_version == 'latest'
    - deploy_operator_source == 'quay'

- name: Setup non-production Orchestrator index image
  when: deploy_operator_source != 'production'
  block:
    - name: Set Orchestrator index image to user defined image
      ansible.builtin.set_fact:
        orch_op_index_image: "{{ deploy_operator_version }}"
      when: deploy_operator_version != 'latest'

    - name: Debug out Orchestrator index image to deploy from
      debug:
        msg: |
          ORCHESTRATOR_OPERATOR_INDEX_IMAGE={{ orch_op_index_image }}

    - name: Create Orchestrator Operator CatalogSource
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ansible.builtin.shell: |
        cat <<EOF | oc apply -f -
        apiVersion: operators.coreos.com/v1alpha1
        kind: CatalogSource
        metadata:
          name: orchestrator-operator
          namespace: openshift-marketplace
        spec:
          displayName: Orchestrator Operator {{ orch_op_tag }}
          publisher: Red Hat
          sourceType: grpc
          grpcPodConfig:
            securityContextConfig: restricted
          image: {{ orch_op_index_image }}
          updateStrategy:
            registryPoll:
              interval: 10m
        EOF

    - name: Wait for CatalogSource and related Pod to successfully start
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ansible.builtin.shell: |
        set -e
        oc wait -n openshift-marketplace catalogsource/orchestrator-operator \
        --for=jsonpath='{.status.connectionState.lastObservedState}'=READY --timeout=30s

        oc wait -n openshift-marketplace pod -l olm.catalogSource=orchestrator-operator \
        --for=condition=Ready --timeout=60s
      retries: 3
      delay: 20
      register: catalog_source_pod
      until: catalog_source_pod is success

- name: Create subscription from latest channel
  vars:
    tmp_catalog_source: "{{ 'redhat-operators' if deploy_operator_source == 'production' else 'orchestrator-operator' }}"
  block:
    - name: Capture channels from orchestrator operator package manifests
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ansible.builtin.shell: |
        oc get packagemanifests -l catalog={{ tmp_catalog_source }} -o json |\
        jq -r '.items[] | select(.metadata.name=="orchestrator-operator") | .status.channels[].name'
      register: tmp_cs_channels
      until: tmp_cs_channels['stdout_lines'] | length > 0
      delay: 30
      retries: 15

    - name: Set Orchestrator Operator channel to first channel available
      ansible.builtin.set_fact:
        orch_op_channel: "{{ tmp_cs_channels['stdout_lines'] | first }}"

    - name: Create Orchestrator Operator Subscription
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      ansible.builtin.shell: |
        cat <<EOF | oc apply -f -
        apiVersion: operators.coreos.com/v1alpha1
        kind: Subscription
        metadata:
          name: orchestrator-operator
          namespace: openshift-operators
        spec:
          channel: {{ orch_op_channel }}
          installPlanApproval: Automatic
          name: orchestrator-operator
          source: {{ tmp_catalog_source }}
          sourceNamespace: openshift-marketplace
        EOF

- name: Wait for Orchestrator Operator pod to start successfully
  environment:
    KUBECONFIG: "{{ kubeconfig_path }}"
  block:
    - name: Remove antigo deployment do Logic Operator (evita erro de selector imutável)
      ansible.builtin.shell: |
        oc delete deployment -l app.kubernetes.io/name=sonataflow-operator -n openshift-serverless-logic --ignore-not-found
      failed_when: false

    - name: Wait for Subscription to report installedCSV
      ansible.builtin.shell: |
        oc get subscription.operators.coreos.com orchestrator-operator -n openshift-operators -o jsonpath='{.status.installedCSV}'
      register: orch_installed_csv
      retries: 20
      delay: 15
      until: orch_installed_csv.stdout != ''

    - name: Wait CSV condition
      ansible.builtin.shell: |
        oc wait csv/{{ orch_installed_csv.stdout }} -n openshift-operators --for=jsonpath='{.status.phase}'=Succeeded --timeout=5m

    - name: Wait for operator deployment pods Ready
      ansible.builtin.shell: |
        oc rollout status deployment/orchestrator-operator -n openshift-operators --timeout=5m
      failed_when: false # O deployment pode ter 0 replicas se o operador está rodando via OLM
